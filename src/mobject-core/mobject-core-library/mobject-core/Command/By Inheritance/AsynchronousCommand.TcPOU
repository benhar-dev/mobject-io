<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="AsynchronousCommand" Id="{4573ba5e-f595-4af2-9ceb-09fc18c9edbd}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'linkalways'}
{attribute 'no_explicit_call' := 'do not call this POU directly'}
{attribute 'enable_dynamic_creation'}
FUNCTION_BLOCK ABSTRACT AsynchronousCommand EXTENDS Disposable IMPLEMENTS I_CyclicCalled, I_Command, I_CanReleaseWhenDone
VAR
	cyclicCall : ManualCyclicCall(THIS^);
	commandFeedback : I_CommandFeedbackReadWrite;
	commandHasCompleted : BOOL;
	disposeOnceComplete : BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="Abstract" Id="{be4e69cc-0c81-4045-8111-c266dd4ab910}" />
    <Folder Name="Private" Id="{9d5c5227-52f5-4c40-92e7-a0bbae19ea54}" />
    <Folder Name="Protected" Id="{096f4fe6-5bb2-4bb8-a6bb-832023512d0b}" />
    <Method Name="Abort" Id="{60afcb50-e5af-4421-b1bc-7eeb69aa83d0}">
      <Declaration><![CDATA[METHOD PUBLIC Abort : I_CanReleaseWhenDone
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Abort := THIS^;

IF IsAborting() THEN
	RETURN;
END_IF

IF HasCompleted() THEN
	RETURN;
END_IF

commandFeedback.SetAborting();

OnAbort(commandFeedback);

IF HasCompleted() THEN
	DisableCyclicCalling();
	CompleteTheCommand();
	RETURN;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ClearFeedback" Id="{5b224ecb-5d28-4495-9f77-edea9dba7241}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE ClearFeedback
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[commandFeedback.Release();
commandFeedback := 0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CompleteTheCommand" Id="{3f77f6ca-3ccf-430a-b4f3-4ad11e70ec64}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE CompleteTheCommand
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ClearFeedback();

IF disposeOnceComplete THEN
	DisposeCommand();	
END_IF

OnExecuteComplete();

commandHasCompleted := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="CyclicCall" Id="{7d4453bc-d846-4b1a-925e-f901cb1b6de8}">
      <Declaration><![CDATA[METHOD PUBLIC CyclicCall
VAR_INPUT
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsStillBusyExecuting() THEN
	WhileBusy(commandFeedback);
END_IF

IF IsAborting() THEN
	WhileAborting(commandFeedback);
END_IF

IF NOT HasCompleted() THEN 
	RETURN;
END_IF

DisableCyclicCalling();
CompleteTheCommand();]]></ST>
      </Implementation>
    </Method>
    <Method Name="DisableCyclicCalling" Id="{8e9808f9-8f6a-41de-8ce9-d3f6ceea26b0}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE DisableCyclicCalling]]></Declaration>
      <Implementation>
        <ST><![CDATA[cyclicCall.Disable();]]></ST>
      </Implementation>
    </Method>
    <Method Name="DisposeCommand" Id="{96c94693-293c-467d-b91d-0570c6b8b7f5}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE DisposeCommand
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[disposeOnceComplete := FALSE;

SUPER^.OnDispose();]]></ST>
      </Implementation>
    </Method>
    <Method Name="EnableCyclicCalling" Id="{7c44a651-0968-483b-840e-e2352a4d8094}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE EnableCyclicCalling]]></Declaration>
      <Implementation>
        <ST><![CDATA[cyclicCall.Enable();]]></ST>
      </Implementation>
    </Method>
    <Method Name="Execute" Id="{245940fa-5663-43ee-90f4-5403d4f93cb7}">
      <Declaration><![CDATA[METHOD PUBLIC Execute : I_CanReleaseWhenDone
VAR_INPUT
	Feedback : REFERENCE TO I_CommandFeedback;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Execute := THIS^;

IF feedback <> 0 THEN 
	feedback.Release();
END_IF

IF IsAlreadyExecuting() THEN

	IF __ISVALIDREF(feedback) THEN
		feedback := commandFeedback;
		feedback.AddReference();
	END_IF
	
	RETURN;
	
END_IF

IF commandFeedback <> 0 THEN 
	commandFeedback.Release();
END_IF

commandFeedback := GetCustomFeedback();

IF commandFeedback = 0 THEN
	commandFeedback := GetStandardFeedback();
END_IF

IF __ISVALIDREF(feedback) THEN
	feedback := commandFeedback;
	feedback.AddReference();
END_IF

commandFeedback.SetBusy();

OnExecute(commandFeedback);

IF HasCompleted() THEN
	CompleteTheCommand();
	RETURN;
END_IF

EnableCyclicCalling();]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetCustomFeedback" Id="{97fb2c85-2042-475d-9a48-58f6e7709092}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED GetCustomFeedback : I_CommandFeedbackReadWrite
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="GetStandardFeedback" Id="{f5b46f8e-e92c-488b-8d47-06f23dec2c3b}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PROTECTED GetStandardFeedback : I_CommandFeedbackReadWrite
VAR
	feedback : POINTER TO CommandFeedback;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[feedback := __NEW(CommandFeedback);
GetStandardFeedback := feedback^;]]></ST>
      </Implementation>
    </Method>
    <Method Name="HasCompleted" Id="{57254ea6-8fe5-4889-8db3-4e6ee8636f4b}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE HasCompleted : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF commandFeedback = 0 THEN
	HasCompleted := commandHasCompleted;
	RETURN;
END_IF

HasCompleted := not commandFeedback.Busy;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsAborting" Id="{826caf00-4fda-4d36-a963-3391fd5b8d02}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE IsAborting : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF commandFeedback = 0 THEN
	RETURN;
END_IF

IsAborting := commandFeedback.Aborting;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsAlreadyExecuting" Id="{2e8792df-35cb-4676-8920-db1b70c114b0}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE IsAlreadyExecuting : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF commandFeedback = 0 THEN
	RETURN;
END_IF

IsAlreadyExecuting := commandFeedback.Busy;]]></ST>
      </Implementation>
    </Method>
    <Method Name="IsStillBusyExecuting" Id="{b51705de-1d6d-48e7-bdae-d504980cfc15}" FolderPath="Private\">
      <Declaration><![CDATA[METHOD PRIVATE IsStillBusyExecuting : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF commandFeedback = 0 THEN
	RETURN;
END_IF

IsStillBusyExecuting := commandFeedback.Busy and not commandFeedback.Aborting;]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnAbort" Id="{434a9592-740f-4773-aecb-a14d6ec189f2}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED OnAbort
VAR_INPUT
	CommandState : I_AsynchronousCommandAbortingState;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// override this method when a command needs time to "abort".
// if your aborting code take more than one cycle to completed then do not SetAborted() here, rather use SetAborted inside WhileAborting.
CommandState.SetAborted();]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnDispose" Id="{5ff28acb-f4dc-4a9e-8c17-5e597a32b0bf}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED OnDispose
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsAlreadyExecuting() THEN 
	disposeOnceComplete := TRUE;
	Abort();
	RETURN;	
END_IF

DisposeCommand();]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnExecute" Id="{4ead10dc-3960-417d-bc9f-9eb0b39493b9}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED OnExecute
VAR_INPUT
	CommandState : I_AsynchronousCommandBusyState;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="OnExecuteComplete" Id="{402c5721-0aa2-4b06-b79b-477923b3c1d3}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED OnExecuteComplete
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ThenRelease" Id="{f14c49ed-80c5-440c-a292-a74bf9c9d2ce}">
      <Declaration><![CDATA[METHOD PUBLIC ThenRelease
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF HasCompleted() THEN
	DisposeCommand();
	RETURN;
END_IF

disposeOnceComplete := true;]]></ST>
      </Implementation>
    </Method>
    <Method Name="WhileAborting" Id="{ce6eb5fa-6b19-440c-b4ec-8ab0fa207070}" FolderPath="Protected\">
      <Declaration><![CDATA[METHOD PROTECTED WhileAborting
VAR_INPUT
	CommandState : I_AsynchronousCommandAbortingState;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// you must override both OnAbort and WhileAborting to use this method.
// if SetAborted has not been called during OnAbort then this method will be cyclically called until you do;
CommandState.SetAborted();]]></ST>
      </Implementation>
    </Method>
    <Method Name="WhileBusy" Id="{6b6b99f4-f4dd-4ca8-96fd-a4ad4ce31355}" FolderPath="Abstract\">
      <Declaration><![CDATA[METHOD PROTECTED ABSTRACT WhileBusy
VAR_INPUT
	CommandState : I_AsynchronousCommandBusyState;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// This will be called cyclically until the command has finished executing.  
// once done use the command below to complete the execute state.
//commandState.SetDone();

// use SetError to cancel the command.
//CommandState.SetError(ErrorID:=0);]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>